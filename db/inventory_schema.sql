-- Inventory Items (Skladové karty)
create table public.inventory_items (
  id bigint generated by default as identity not null primary key,
  name text not null,
  description text,
  ean text, -- Barcode / QR code
  sku text, -- Internal stock keeping unit
  quantity numeric not null default 0,
  unit text default 'ks',
  min_quantity numeric default 0, -- Reorder point
  avg_price numeric default 0, -- Average purchase price for valuation
  last_purchase_price numeric default 0,
  location text, -- Shelf/Bin location
  
  -- Foreign Keys
  supplier_item_id bigint references public.supplier_items(id), -- Link to supplier catalog if applicable
  
  -- Metadata
  is_active boolean default true,
  created_at timestamp with time zone not null default now(),
  updated_at timestamp with time zone not null default now()
);

-- Indexes for items
create index idx_inventory_items_ean on public.inventory_items(ean);
create index idx_inventory_items_name on public.inventory_items using gin (to_tsvector('simple', name));

-- Inventory Movements (Pohyby skladu)
create table public.inventory_movements (
  id bigint generated by default as identity not null primary key,
  inventory_item_id bigint not null references public.inventory_items(id) on delete cascade,
  
  type text not null check (type in ('RECEIPT', 'ISSUE', 'AUDIT', 'RETURN', 'TRANSFER')),
  -- RECEIPT = Příjem
  -- ISSUE = Výdej
  -- AUDIT = Inventura (korekce)
  -- RETURN = Vratka
  
  quantity numeric not null, -- Positive adds to stock, negative follows logic but usually stored as positive with type determining effect? 
  -- Let's stick to: Positive Amount always. Type determines direction.
  -- OR: Store signed value? Storing signed value is easier for aggregation.
  -- DECISION: Store 'quantity_change' as signed value.
  quantity_change numeric not null,
  
  price numeric, -- Unit price at the time of movement (cost price for issue, purchase price for receipt)
  
  -- Context
  reference_number text, -- Invoice #, Delivery Note #
  note text,
  
  -- Links to other modules
  action_id bigint references public.akce(id), -- Project where item was used
  user_id uuid references auth.users(id), -- Who performed the action
  
  created_at timestamp with time zone not null default now()
);

-- Indexes for movements
create index idx_inventory_movements_item_id on public.inventory_movements(inventory_item_id);
create index idx_inventory_movements_action_id on public.inventory_movements(action_id);
create index idx_inventory_movements_date on public.inventory_movements(created_at);

-- RLS Policies
alter table public.inventory_items enable row level security;
alter table public.inventory_movements enable row level security;

create policy "Authenticated users can view inventory"
  on public.inventory_items for select
  to authenticated
  using (true);

create policy "Authenticated users can modify inventory"
  on public.inventory_items for all
  to authenticated
  using (true);

create policy "Authenticated users can view movements"
  on public.inventory_movements for select
  to authenticated
  using (true);

create policy "Authenticated users can create movements"
  on public.inventory_movements for insert
  to authenticated
  with check (true);

-- Triggers for Updated At
create extension if not exists moddatetime schema extensions;

create trigger handle_updated_at before update on public.inventory_items
  for each row execute procedure moddatetime (updated_at);
